!<arch>
ft_strlen.s/    0           0     0     644     536       `
section .text
    global ft_strlen

ft_strlen:
    xor rax, rax        ; Lorsqu'on le compare a lui meme, c'est forcement initialise a 0

.loop:
    cmp byte [rdi], 0   ; Verifier si le caractere actuel de la chaine (rdi) est nul
    je .done            ; Si c'est le cas, sortir de la boucle
    inc rax             ; Incrementer
    inc rdi             ; Passer au caractere suivant, equivalent de i++
    jmp .loop           ; Repeter le processus

.done:
    ret                 ; Renvoyer la valeur de retour, donc le registre rax
ft_strcpy.s/    0           0     0     644     605       `
section .text
    global ft_strcpy

ft_strcpy:

.loop:
    mov al, [rsi]           ; Deplace la premiere donneee du tableau dans un registre de 8 bits  
    test al, al             ; Savoir si la donnee vaut 0
    je .done                ; Sortir de la boucle

    mov [rdi], al           ; Deplacer le caractere sur le tableau rdi 
    inc rsi                 ; Incrementer le pointeur de source
    inc rdi                 ; Incrementer le pointeur de destination
    jmp .loop               ; Loop jusqua trouver le 0

.done:
    mov byte [rdi], 0       ; Mettre \0, il y a aussi mov [rdi], al
    ret

ft_strcmp.s/    0           0     0     644     1192      `
section .text
    global ft_strcmp

ft_strcmp:
    ; RDI contient l'adresse de la première chaîne (s1)
    ; RSI contient l'adresse de la deuxième chaîne (s2)
    
    xor     rax, rax           ; Initialiser le résultat à zéro
    
.loop:
    mov     al, [rdi]          ; Charger le caractère actuel de s1 dans AL
    cmp     al, [rsi]          ; Comparer le caractère actuel de s1 avec celui de s2
    je      .next_char         ; Si les caractères sont égaux, passer au caractère suivant
    
    ; Si les caractères sont différents, calculer la différence et retourner le résultat
    sub     al, [rsi]          ; Soustraire le caractère de s2 de celui de s1
    ret                        ; Renvoyer le résultat
    
.next_char:
    test    al, al             ; Vérifier si le caractère actuel est nul
    jz      .done              ; Si c'est le cas, sortir de la boucle
    
    inc     rdi                ; Passer au caractère suivant de s1
    inc     rsi                ; Passer au caractère suivant de s2
    jmp     .loop              ; Répéter le processus
    
.done:
    xor     rax, rax           ; Si les chaînes sont identiques, retourner 0
    ret
ft_write.s/     0           0     0     644     919       `
section .data
    error_message db 'ft_write error', 0

extern __errno_location

section .text
    global ft_write

ft_write:
    ; 3 Parametres int fd, const void *buf, size_t count
    ; RDI pour int fd
    ; RSI pour const void* buf
    ; RDX pour size_t count

    mov rax, 1              ; Code 1 pour l'appel systeme write
    mov rdi, rdi            ; charge fd dans le registre rdi
    mov rsi, rsi            ; charge buf dans le registre rsi
    mov rdx, rdx            ; charge count dans le registre rdx
    
    syscall
    cmp rax, 0              ; Tcheck si syscall write est a 0
    jl .error
    ret

.error:
	call __errno_location
    test rax, rax           ; Verifier si le pointeur retourne par __errno_location est null
    jz .error_exit          ; Quitter si le pointeur est null
    
    ; Si le pointeur est valide
    mov rdi, rax
    mov qword [rdi], -1

.error_exit:
    mov rax, -1
    ret
ft_read.s/      0           0     0     644     546       `
section .data
    error_message db 'ft_read error', 0

extern __errno_location

section .text
    global ft_read

ft_read:
    mov rax, 0
    mov rdi, rdi
    mov rsi, rsi
    mov rdx, rdx

    syscall
    cmp rax, 0
    jl .error
    ret
    
.error:
	call __errno_location
    test rax, rax           ; Verifier si le pointeur retourne par __errno_location est null
    jz .error_exit          ; Quitter si le pointeur est null
    
    ; Si le pointeur est valide
    mov rdi, rax
    mov qword [rdi], -1

.error_exit:
    mov rax, -1
    ret
ft_strdup.s/    0           0     0     644     806       `
section .text
    global ft_strdup

extern strlen
extern malloc
extern strcpy

ft_strdup:
    xor rax, rax                ; Initialisation a 0
    call strlen                 ; Call 
    push rdi                    ; Pousse la valeur actuelle de rdi sur la pile avant de l'utiliser dans une operation qui pourrait la modifier
    mov rdi, rax                ; deplace la longueur de la chaine dans le premier argument de la fonction malloc
    call malloc                 ; Alloue rax octets
    pop rsi                     ; Cette instruction dépile la valeur précédemment sauvegardée de rdi de la pile et la stocke dans rsi. Cela restaure la valeur précédente de rdi qui a été sauvegardée avec push rdi
    mov rdi, rax                ; rax contient le pointeur alloue
    call strcpy 

    ret
